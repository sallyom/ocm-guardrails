# ConfigMap: A2A bridge for NPS Agent
# Translates Google A2A JSON-RPC protocol to the NPS Agent's /invocations API
# Based on manifests/openclaw/base/a2a-bridge-configmap.yaml but adapted for
# MLflow ResponsesAgent format instead of OpenAI chat completions
apiVersion: v1
kind: ConfigMap
metadata:
  name: nps-agent-a2a-bridge
  labels:
    app: nps-agent
    app.kubernetes.io/component: a2a-bridge
data:
  a2a-bridge.js: |
    'use strict';
    const http = require('http');
    const crypto = require('crypto');
    const fs = require('fs');

    const PORT = 8080;
    const BACKEND_HOST = '127.0.0.1';
    const BACKEND_PORT = parseInt(process.env.BACKEND_PORT || '8090');
    const AGENT_NAME = process.env.AGENT_NAME || 'NPS Agent';
    const AGENT_DESCRIPTION = process.env.AGENT_DESCRIPTION || 'National Park Service Information Assistant';
    const SVID_CERT_PATH = process.env.SVID_CERT_PATH || '/opt/svid.pem';
    const SVID_KEY_PATH = process.env.SVID_KEY_PATH || '/opt/svid_key.pem';
    const SIGNING_ENABLED = process.env.AGENTCARD_SIGNING_ENABLED !== 'false';
    const SVID_POLL_INTERVAL_MS = 30000;

    const skills = [
      {
        id: 'nps',
        name: 'Park Information',
        description: 'Ask about U.S. national parks â€” locations, alerts, campgrounds, events, visitor centers',
        examples: [
          'What national parks are in California?',
          'Are there any alerts for Yellowstone?',
          'What campgrounds are at the Grand Canyon?'
        ]
      }
    ];

    // --- JWS Agent Card Signing (SPIRE SVID) ---

    function base64urlEncode(buf) {
      return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    function parsePEMCerts(pemData) {
      const certs = [];
      const regex = /-----BEGIN CERTIFICATE-----\n([\s\S]*?)-----END CERTIFICATE-----/g;
      let match;
      while ((match = regex.exec(pemData)) !== null) {
        certs.push(match[1].replace(/\n/g, ''));
      }
      return certs;
    }

    function detectAlgorithm(privateKey) {
      const keyObj = crypto.createPrivateKey(privateKey);
      const details = keyObj.asymmetricKeyType;
      if (details === 'ec') {
        const jwk = keyObj.export({ format: 'jwk' });
        switch (jwk.crv) {
          case 'P-256': return 'ES256';
          case 'P-384': return 'ES384';
          case 'P-521': return 'ES512';
        }
      }
      if (details === 'rsa') return 'RS256';
      throw new Error(`Unsupported key type: ${details}`);
    }

    function canonicalJSON(obj) {
      if (obj === null || obj === undefined) return undefined;
      if (typeof obj !== 'object') return JSON.stringify(obj);
      if (Array.isArray(obj)) {
        const items = obj.map(v => canonicalJSON(v)).filter(v => v !== undefined);
        return '[' + items.join(',') + ']';
      }
      const keys = Object.keys(obj).sort();
      const pairs = [];
      for (const k of keys) {
        if (k === 'signatures') continue;
        const v = obj[k];
        if (v === null || v === undefined || v === '') continue;
        if (Array.isArray(v) && v.length === 0) continue;
        if (typeof v === 'object' && !Array.isArray(v) && Object.keys(v).length === 0) continue;
        const val = canonicalJSON(v);
        if (val !== undefined) pairs.push(JSON.stringify(k) + ':' + val);
      }
      return '{' + pairs.join(',') + '}';
    }

    function signAgentCard(cardObj, certPEM, keyPEM) {
      const alg = detectAlgorithm(keyPEM);
      const x5cChain = parsePEMCerts(certPEM);
      if (x5cChain.length === 0) throw new Error('No certificates found in SVID PEM');

      const protectedHeader = { alg, x5c: x5cChain };
      const protectedB64 = base64urlEncode(Buffer.from(JSON.stringify(protectedHeader)));
      const payload = canonicalJSON(cardObj);
      const payloadB64 = base64urlEncode(Buffer.from(payload));
      const signingInput = protectedB64 + '.' + payloadB64;

      let hashAlg;
      switch (alg) {
        case 'ES256': case 'RS256': hashAlg = 'sha256'; break;
        case 'ES384': case 'RS384': hashAlg = 'sha384'; break;
        case 'ES512': case 'RS512': hashAlg = 'sha512'; break;
        default: throw new Error(`Unsupported algorithm: ${alg}`);
      }

      const privateKey = crypto.createPrivateKey(keyPEM);
      let signatureB64;

      if (alg.startsWith('ES')) {
        const sig = crypto.sign(null, Buffer.from(signingInput), {
          key: privateKey,
          dsaEncoding: 'ieee-p1363'
        });
        signatureB64 = base64urlEncode(sig);
      } else {
        const sig = crypto.sign(hashAlg, Buffer.from(signingInput), privateKey);
        signatureB64 = base64urlEncode(sig);
      }

      return { protected: protectedB64, signature: signatureB64 };
    }

    let cachedCertPEM = null;
    let cachedKeyPEM = null;
    let cachedSignedCard = null;
    let lastSvidMtime = 0;

    function loadSVIDIfChanged() {
      try {
        if (!fs.existsSync(SVID_CERT_PATH) || !fs.existsSync(SVID_KEY_PATH)) return false;
        const stat = fs.statSync(SVID_CERT_PATH);
        const mtime = stat.mtimeMs;
        if (mtime === lastSvidMtime && cachedCertPEM) return false;
        cachedCertPEM = fs.readFileSync(SVID_CERT_PATH, 'utf8');
        cachedKeyPEM = fs.readFileSync(SVID_KEY_PATH, 'utf8');
        lastSvidMtime = mtime;
        cachedSignedCard = null;
        console.log('SVID reloaded (cert changed)');
        return true;
      } catch (err) {
        console.error('Failed to load SVID:', err.message);
        return false;
      }
    }

    function getAgentCard() {
      const baseCard = {
        capabilities: { streaming: false },
        description: AGENT_DESCRIPTION,
        name: AGENT_NAME,
        skills: skills,
        url: `http://nps-agent.${process.env.POD_NAMESPACE || 'nps-agent'}.svc.cluster.local:${PORT}`,
        version: '1.0.0'
      };

      if (!SIGNING_ENABLED || !cachedCertPEM || !cachedKeyPEM) {
        return baseCard;
      }

      if (cachedSignedCard) return cachedSignedCard;

      try {
        const sig = signAgentCard(baseCard, cachedCertPEM, cachedKeyPEM);
        cachedSignedCard = { ...baseCard, signatures: [sig] };
        console.log('Agent card signed successfully');
        return cachedSignedCard;
      } catch (err) {
        console.error('Agent card signing failed, serving unsigned:', err.message);
        return baseCard;
      }
    }

    loadSVIDIfChanged();
    setInterval(() => {
      if (loadSVIDIfChanged()) cachedSignedCard = null;
    }, SVID_POLL_INTERVAL_MS);

    function readBody(req) {
      return new Promise((resolve, reject) => {
        const chunks = [];
        req.on('data', chunk => chunks.push(chunk));
        req.on('end', () => resolve(Buffer.concat(chunks).toString()));
        req.on('error', reject);
      });
    }

    function backendRequest(path, method, body, headers) {
      return new Promise((resolve, reject) => {
        const req = http.request({
          hostname: BACKEND_HOST,
          port: BACKEND_PORT,
          path: path,
          method: method,
          headers: headers,
          timeout: 300000
        }, (res) => {
          const chunks = [];
          res.on('data', chunk => chunks.push(chunk));
          res.on('end', () => {
            const data = Buffer.concat(chunks).toString();
            try {
              resolve({ status: res.statusCode, body: JSON.parse(data) });
            } catch {
              resolve({ status: res.statusCode, body: data });
            }
          });
        });
        req.on('error', reject);
        req.on('timeout', () => { req.destroy(); reject(new Error('Backend timeout')); });
        if (body) req.write(body);
        req.end();
      });
    }

    async function handleA2AMessage(a2aRequest) {
      // Extract message text from A2A parts
      const parts = a2aRequest.params?.message?.parts || [];
      const text = parts
        .filter(p => p.kind === 'text' || (typeof p.text === 'string'))
        .map(p => p.text)
        .join('\n');

      if (!text) {
        return {
          jsonrpc: '2.0',
          id: a2aRequest.id,
          error: { code: -32602, message: 'No text content in message parts' }
        };
      }

      // Translate to NPS Agent /invocations format (MLflow ResponsesAgent)
      // Format: { input: [{ role: "user", content: "text" }] }
      const payload = JSON.stringify({ input: [{ role: 'user', content: text }] });

      const headers = {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(payload)
      };

      const result = await backendRequest('/invocations', 'POST', payload, headers);

      if (result.status !== 200) {
        console.error('NPS Agent returned', result.status, result.body);
        return {
          jsonrpc: '2.0',
          id: a2aRequest.id,
          error: { code: -32603, message: `NPS Agent error: ${result.status}` }
        };
      }

      // Extract response from MLflow ResponsesAgent format
      // Actual format: { output: [{ type: "message", content: [{ type: "output_text", text: "..." }], role: "assistant" }] }
      let content = 'No response from NPS Agent';
      const output = result.body?.output;
      if (Array.isArray(output) && output.length > 0) {
        const lastMsg = output[output.length - 1];
        if (typeof lastMsg === 'string') {
          content = lastMsg;
        } else if (Array.isArray(lastMsg?.content)) {
          const textPart = lastMsg.content.find(c => c.type === 'output_text' || c.type === 'text' || c.text);
          if (textPart) content = textPart.text || textPart;
        } else if (typeof lastMsg?.content === 'string') {
          content = lastMsg.content;
        }
      } else if (typeof output === 'string') {
        content = output;
      }

      return {
        jsonrpc: '2.0',
        id: a2aRequest.id,
        result: {
          id: crypto.randomUUID(),
          status: {
            state: 'COMPLETED',
            message: {
              role: 'agent',
              parts: [{ kind: 'text', text: content }],
              messageId: crypto.randomUUID()
            }
          }
        }
      };
    }

    const server = http.createServer(async (req, res) => {
      const url = new URL(req.url, `http://${req.headers.host}`);

      if (req.method === 'GET' && (url.pathname === '/.well-known/agent-card.json' || url.pathname === '/.well-known/agent.json')) {
        const card = getAgentCard();
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(card));
        return;
      }

      if (req.method === 'GET' && (url.pathname === '/' || url.pathname === '/health')) {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          status: 'ok',
          bridge: 'nps-agent-a2a',
          signing: SIGNING_ENABLED && !!cachedCertPEM ? 'active' : 'disabled'
        }));
        return;
      }

      // A2A JSON-RPC endpoint
      if (req.method === 'POST' && (url.pathname === '/' || url.pathname === '/a2a')) {
        try {
          const body = await readBody(req);
          const a2aRequest = JSON.parse(body);

          if (a2aRequest.method === 'message/send' || a2aRequest.method === 'message/stream') {
            const response = await handleA2AMessage(a2aRequest);
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(response));
          } else {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              jsonrpc: '2.0',
              id: a2aRequest.id,
              error: { code: -32601, message: `Method not supported: ${a2aRequest.method}` }
            }));
          }
        } catch (err) {
          console.error('A2A bridge error:', err);
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            jsonrpc: '2.0',
            error: { code: -32603, message: err.message }
          }));
        }
        return;
      }

      res.writeHead(404, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Not found' }));
    });

    server.listen(PORT, '0.0.0.0', () => {
      console.log(`NPS Agent A2A bridge listening on 0.0.0.0:${PORT}`);
      console.log(`Backend: ${BACKEND_HOST}:${BACKEND_PORT}/invocations`);
      console.log(`Agent card: http://0.0.0.0:${PORT}/.well-known/agent.json`);
      console.log(`Signing: ${SIGNING_ENABLED ? 'enabled' : 'disabled'}`);
    });
